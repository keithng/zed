<!DOCTYPE HTML>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=9">
<meta http-equiv="Content-Type" content="text/html" charset="utf-8">
<script src="./lib/jquery-1.9.1.min.js" type="text/javascript" charset="utf-8"></script>
<script src="./lib/raphael-min.js" type="text/javascript" charset="utf-8"></script>
<script src="./lib/zed.js" type="text/javascript" charset="utf-8"></script>
<title>EggSlicer: Interactive cross-tab analysis for surveys</title>
<script src="./data/EggSlicer.data" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
window.onload = function () {
	logger("EggSlicer(): Initialising.");
	var L = new zLayout({width:920, height:860});
	PAPER = zt.makePaper(L);

	//logger("EggSlicer(): Collating and crunching data.");
	var i, dc, controldc,
		SHOWN_QUESTIONS = [
			[234, 235, 237, 239, 240],
			[234, 235, 243, 244, 245, 247],
			[234, 235, 248, 249, 254, 255, 256, 257, 258, 259, 260],
			[234, 235, 276, 277, 278],
			[234, 235, 280, 284, 291, 297, 303, 309, 315, 321, 327, 333]
		];

	var INIT_TIME = 0, INIT_SPLIT = 0, INIT_QUESTION = 0,
		dc = new zDataCube(3).importProtoCube(protoCube);

	with (dc) {
		setShown(0, [4, 3, 2, 1, 0]); // Time

/*		// Questions
		var rootGen = [null, getMeta("hierarchy", {d:1, a:0}), getMeta("hierarchy", {d:2, a:0})];
		addDataType("valStacked");
		setMeta("Questions", "title", 1);
		for (i = 0; i < rootGen[1].length; i++) stackChildren("val", "all", 1, rootGen[1][i]);
		// Splits
		setMeta("Splits", "title", 2);
		for (i = 0; i < rootGen[2].length; i++) stackChildren("val", ["all", 0, "all"], 2, rootGen[2][i]);

		// Trim data for export
		var stacked, list = listCells("all");
		for (i = 0; i < list.length; i++) {
			val = getData("val", list[i]);
			stacked = getData("valStacked", list[i]);
			if (val == null) setData(0, "val", list[i]);
			if (val == null || stacked == null) setData(0, "valStacked", list[i]);
			else setData({s:zt.roundTo(stacked.start, 3), e:zt.roundTo(stacked.end, 3)}, "valStacked", list[i]);
		};
		console.log(zt.asString(exportProtoCube()));
/**/
		// Used by axes to get questions (dc is used by swarm to get answers)
		with (controldc = madroxClone()) {
			setShown(1, SHOWN_QUESTIONS[INIT_TIME]);
			setShown(2, za.subtract(getMeta("hierarchy", {d:2, a:0}), [48, 49, 50, 51])); // Hide some splits
		};
	};

	var Y = zt.parseStyle({
			swarm:{
				question:{
					margin:0,
					format:{wrap:75},
					"font-size":18,
					"font-weight":"bold"
				},
				noData:{"font-size":200},
				bar:{
					parallelSize:0.75,
					stroke:null,
					"stroke-opacity":0,
					opacity:0.8,
					highlight:{opacity:1}
				},
				barLabel:{
					format:{wrap:10},
					textxAlign:"xCentre",
					"font-size":16,
					"font-weight":"bold",
					fill:"#fff",
					opacity:0.9
				},
				rowLabel:{
					margin:10,
					format:{wrap:15},
					"font-size":14
				},
				columnLabel:{
					margin:0,
					format:{wrap:18},
					"font-size":14,
					branch:{}
				}
			},
			controlAxis:{
				parallelSize:0.6,
				perpendicularSize:0.6,
				rowHeight:20,
				disaggregate:{t:800, e:"backOut"},
				axisTitle:{
					margin:6,
					fill:"#444",
					"font-size":24
				},
				notch:{
					fill:"#ddd",
					select:{fill:"orange"}
				},
				label:{
					margin:8,
					fill:"#999",
					textxAlign:"left",
					"font-size":14,
					"font-weight":"bold",
					highlight:{fill:"#222"},
					select:{fill:"#222"}
				}
			},
			tooltipBox:{
				margin:15,
				format:{wrap:40},
				fill:"#222202",
				"font-size":12,
				background:{
					rounded:10,
					fill:"#cdddfd",
					"opacity":0.8,
					stroke:null,
					"stroke-width":0,
					"stroke-opacity":0
				}
			},
			credits:{fill:"#333"}
		});

	with (L) {
		L.swarmArea = new zLayout({
			anchor:getPoint(0, 0.1),
			width:width,
			height:height * 0.6
		});
		L.controlArea = new zLayout({
			anchor:getPoint(0.1, 0.72),
			width:width * 0.8
		});
		L.credits = {anchor:getPoint(1,1), xAlign:"right", yAlign:"bottom"};
	};
	with (L.swarmArea) {
		L.iAxis = {
			anchor:getPoint(0.1, 0.1),
			width:height * 0.8
		};
		L.dAxis = {
			anchor:getPoint(0.1, 0),
			width:width * 0.85
		};
	};
	with (L.controlArea) {
		L.tControl = {
			anchor:getPoint(0.1 + 0 * 0.4, 0.1),
			width:controldc.getSize(0, true) * Y.controlAxis.rowHeight,
			height:Y.controlAxis.rowHeight,
			rotation:90,
			yAlign:"bottom"
		};
		L.qControl = {
			anchor:getPoint(0.1 + 1 * 0.4, 0.1),
			width:controldc.getSize(1, true) * Y.controlAxis.rowHeight,
			height:Y.controlAxis.rowHeight,
			rotation:90,
			yAlign:"bottom"
		};
		L.iControl = {
			anchor:getPoint(0.1 + 2 * 0.4, 0.1),
			width:controldc.getSize(2, true) * Y.controlAxis.rowHeight,
			height:Y.controlAxis.rowHeight,
			rotation:90,
			yAlign:"bottom"
		};
	};

	// Functions
	var controlAxisTitle = {
			init:function (S, A, D) {
				return {
					text:dc.meta[S.d].title,
					layout:{anchor:S.layout, yAlign:"bottom"}
				};
			}
		},
		enableControls = function () {
			tControl.mouseEvents();
			qControl.mouseEvents();
			iControl.mouseEvents();
			if (dc.calcData("val", {rs:swarm.R}, "sum") == 0) swarm.add("noData");
			else swarm.remove("noData");
		},
		disableControls = function () {
			tControl.clearEvents();
			qControl.clearEvents();
			iControl.clearEvents();
		},
		notch = {
			type:"zRectangle", mask:"mask",
			init:function (S, A, D, Y) {
				return {mouseEvents:S.baseMouseEvents};
			},
			curr:function (S, A, D, Y, mode) {
				return {
					layout:{
						anchor:S.getPoint({a:A[S.d]}), // If no rPos is defined, find the aPos in axes.i
						width:S.notchWidth, height:S.notchHeight,
// 						width:(mode == "-=" || mode == "+=") ? 1 : (mode == "+<" || mode == "+>") ? S.notchOldWidth : S.notchWidth,  // When inserted/removed inside the visible axis, start/end at width == 1, when adding from edges, use oldWidth
						xAlign:"xCentre", yAlign:S.L.yAlign,
						rotation:S.L.rotation
					}
				};
			}
		};


	var credits = new zTextBox({text:"Created by Keith Ng", layout:L.credits, base:Y.credits}),
		iAxis = new zSmartAxis({layout: L.iAxis, dc:dc, d:2, plan:{axisTitle:null, axisLine:null, notch:null, label:null}}),
		dAxis = new zAxis({layout:L.dAxis, range:[0, 1], plan:{axisTitle:null, axisLine:null, label:null}}),
		// Control panel
		tControl = new zSelectAxis({layout:L.tControl, style:Y.controlAxis, dc:controldc, d:0, selected:{r:INIT_TIME}, plan:{axisTitle:controlAxisTitle, axisLine:null, notch:notch}}),
		qControl = new zSelectAxis({
			layout:L.qControl, style:Y.controlAxis,
			dc:controldc, d:1,
			selected:{r:INIT_QUESTION},
			axes:{t:tControl},
			updateData:function () {
				var c = this;
				c.notchWidth = c.Y.parallelSize * c.L.width / c.dc.getSize(1, true);
				c.notchOldWidth = c.Y.parallelSize * c.L.width / c.dc.oldShown[1].length;
				c.notchHeight = c.Y.perpendicularSize * c.L.height;
				c.setShown(SHOWN_QUESTIONS[tControl.selected.a]);
				c.L.set({width:c.dc.getSize(1, true) * Y.controlAxis.rowHeight});
				c.forSwarms("remove", {d:1, a:za.subtract(c.dc.oldShown[1], c.dc.shown[1])});
				c.forSwarms("add", {d:1, a:za.subtract(c.dc.shown[1], c.dc.oldShown[1])});
				if (c.selected.a == null || c.asRPos({d:1, a:c.selected.a}) == null) c.axisSelect({r:0}); // If the currently selected question does not exist for this time
			},
			axisSelect:function (x) {
				var c = this;
				if (!x.forced && c.asRPos(x) == c.selected.r) return; // Do nothing if it's already selected
				c.select(x);
				c.aChildren = dc.asRPos({d:1, a:dc.findChildren({d:1, a:c.selected.a})});
				if (swarm) {
					swarm.setSpace({d:1, a:c.aChildren});
					swarm.refresh("all");
				};
			},
			plan:{axisTitle:controlAxisTitle, axisLine:null, notch:notch}
		}),
		iControl = new zSelectAxis({
			layout:L.iControl, style:Y.controlAxis,
			dc:controldc, d:2,
			selected:{r:INIT_SPLIT},
			axisSelect:function (x) {
				var c = this,
					aPos = c.asAPos(x),
					t = c.Y.disaggregate.t, e = c.Y.disaggregate.e; // Use default timing/easing
				if (aPos == c.selected.a || !swarm) return;
				disableControls();
				var children = (aPos == 0) ? [0] : dc.findChildren(x),
					oldChildren = (c.selected.a == 0) ? [0] : dc.findChildren(c.selected);
				with (swarm) {
					R[2] = children;
					if (PAPER.noAnimation) {
						logger("EggSlicer.iControl.axisSelect(): Instant redraw.");
						add({d:2, a:children});
						remove({d:2, a:oldChildren});
						refresh("all");
						enableControls();
					} else if (aPos == 0) {
						logger("EggSlicer.iControl.axisSelect(): Reaggregrating.");
						refresh({d:2, a:oldChildren, mode:{noUpdateData:true, reaggregating:true}}, t, e, function () { // Manually put oldChildren back into the centre
							add({d:2, a:0});
							remove({d:2, a:oldChildren}); // When they're back in the centre, replace them with whole
							enableControls();
						});
					} else if (c.selected.a == 0) {
						logger("EggSlicer.iControl.axisSelect(): Disaggregating.");
						add({d:2, a:children, mode:{disaggregating:true}}); // Place in centre
						remove({d:2, a:0}); // Replace whole with children
						refresh({d:2, a:children, mode:{noUpdateData:true}}, t, e, enableControls); // Redraw to normal position
					} else {
						logger("EggSlicer.iControl.axisSelect(): Rediscombobulatronicallating.");
						refresh({d:2, a:oldChildren, mode:{noUpdateData:true, reaggregating:true}}, t, e, function () { // Reset
							add({d:2, a:children, mode:{disaggregating:true}}); // Manually place
							remove({d:2, a:oldChildren});
							refresh({d:2, a:children, mode:{noUpdateData:true}}, t, e, enableControls); // Redraw to normal position
						});
					};
					c.select(x); // Move notch
				};
			},
			plan:{axisTitle:controlAxisTitle, axisLine:null, notch:notch}
		}),
		swarm = new zSwarm({ // Resources
			style:Y.swarm,
			dc:dc, d:1,
			rSpace:[0, dc.asRPos({d:1, a:qControl.aChildren}), 0],
			axes:{i:iAxis, d:dAxis, t:tControl},
			highlighted:null, targHighlighted:null,
			heights:[], insertYs:[], realYs:[],
			updateData:function () {
				var i, sizeVal, stackedSize, sizePos,
					y = Y.swarm.bar;
				for (i = 0; i < dc.getSize(2); i++) { // FIXME: Pretty sure this is wrong
					sizeVal = controldc.getData("val", {as:[tControl.selected.a, 0, i]});
					stackedSize = controldc.getData("valStacked", {as:[tControl.selected.a, 0, i]});
					sizePos = (stackedSize) ? stackedSize.e - sizeVal * 0.5 : sizeVal * 0.5;
					with (L.iAxis) {
						this.heights[i] = width * y.parallelSize * sizeVal;
						this.insertYs[i] = anchor.y + width * (y.parallelSize * sizePos + 0.5 - y.parallelSize * 0.5);
						this.realYs[i] = anchor.y + width * sizePos;
					};
				};
			},
			highlightColumn:function (aPos) {
				var c = this;
				c.targHighlighted = aPos; // targHighlighted will instantly change to reflect what the mouse is over
				c.G.redraw(25, null, function () { // Set delay between calling a highlight and executing
					if (c.targHighlighted != aPos) return; // Quit if targHighlighted has been modified since delay period
					if (c.targHighlighted == c.highlighted) return; // Quit if trying to highlight what's already highlighted
					var unhighlighted = za.subtract(dc.shown[1], aPos);
					c.remove({d:1, a:unhighlighted, role:"barLabel"});
					c.remove({d:1, a:unhighlighted, role:"columnLabel"});
					if (aPos != null) {
						c.add({d:1, a:aPos, role:"barLabel"});
						c.add({d:1, a:aPos, role:"columnLabel"});
						c.highlight({d:1, a:aPos});
					};
					c.reset({d:1, a:unhighlighted});
				});
			},
			plan:{
				question:{
					type:zTextBox, mask:"fixed",
					init:function (S, A, D) {
						return {
							layout:{anchor:L.getPoint(0.03, 0.05), yAlign:"yCentre"}
						};
					},
					curr:function (S, A, D) {
						return {
							text:dc.getMeta("description", {d:1, a:qControl.selected.a})
						};
					}
				},
				bar:{
					type:zRectangle, mask:"mask", directRedraw:true,
					init:function (S, A, D) {
						return {
							fill:dc.getMeta("colour", {d:1, a:A[1]}),
							mouseEvents:function (d) {
								d.hover(function () {S.highlightColumn(A[1])}, function () {S.highlightColumn()});
							}
						};
					},
					curr:function (S, A, D, Y, mode) {
						var aSpace = (mode.disaggregating || mode.reaggregating) ? [A[0], A[1], 0] : A,
							stacked = S.dc.getData("valStacked", {as:aSpace});
						return {
							layout:{
								x:dAxis.getPoint(stacked.s).x,
								y:(mode.disaggregating || mode.reaggregating) ? S.insertYs[A[2]] : S.realYs[A[2]],
								height:S.heights[A[2]],
								width:dAxis.getLength(stacked.e - stacked.s),
								xAlign:"left", yAlign:"yCentre"
							}
						};
					},
				},
				barLabel:{
					type:zTextBox, mask:"mask", ignore:true, directRedraw:true,
					init:function (S, A, D) {
						var leader = S.get({role:"bar", as:A})[0];
						return {
							mouseEvents:leader.O.mouseEvents
						};
					},
					curr:function (S, A, D, Y, mode) {
						var aSpace = (mode.disaggregating || mode.reaggregating) ? [A[0], A[1], 0] : A,
							stacked = S.dc.getData("valStacked", {as:aSpace}),
							dec = zt.mid(0.5, stacked.s, stacked.e),
							val = S.dc.getData("val", {as:A});
						return {
							text:(!val) ? " " : zt.format(val, {m:"%", dp:(val < 0.1) ? 1 : 0}),
							layout:{
								x:dAxis.getPoint(dec).x,
								y:(mode.disaggregating || mode.reaggregating) ? S.insertYs[A[2]] : S.realYs[A[2]],
								xAlign:"xCentre", yAlign:"yCentre"
							}
						};
					}
				},
				rowLabel:{
					type:zTextBox, mask:["na", "na", "mask"], directRedraw:true,
					curr:function (S, A, D, Y, mode) {
						var name = dc.getName({d:2, a:A[2]}),
							val = dc.getData("val", {as:[tControl.selected.a, 0, A[2]]});
						return {
							text:name + "\n(" + zt.format(val, {m:"%", dp:0}) + ")",
							layout:{
								x:iAxis.L.x,
								y:(mode.disaggregating || mode.reaggregating) ? S.insertYs[A[2]] : S.realYs[A[2]],
								xAlign:"right", yAlign:"yCentre"
							}
						};
					}
				},
				columnLabel:{
					type:zTextBox, mask:["na", "mask", "na"], ignore:true, directRedraw:true,
					curr:function (S, A, D) {
						var topR = (S.R[2] instanceof Array) ? za.min(S.R[2]) : S.R[2], // rPos of the top row
							topA = dc.asAPos({d:2, r:topR}), // aPos of the top row
							stacked = dc.getData("valStacked", {as:[tControl.selected.a, A[1], topA]}), // Values for this element in the top row
							dec = zt.mid(0.5, stacked.s, stacked.e);
						return {
							text:S.dc.getName({d:1, a:A[1]}),
							layout:{
								x:dAxis.getPoint(dec).x,
								y:S.realYs[topA] - S.heights[topA] / 2,
								radial:270, radialEnd:15
							}
						}
					}
				},
				noData:{
					type:zTextBox, mask:"fixed", ignore:true,
					init:function (S, A, D) {
						return {
							text:"No data available.",
							layout:{anchor:L.swarmArea.getPoint(0.5, 0.5), xAlign:"xCentre", yAlign:"yCentre"}
						};
					}
				}
			}
		});

	// Initialise
	qControl.select({r:INIT_QUESTION});
	iControl.select({r:INIT_SPLIT});
// 	tControl.select({r:INIT_TIME});
	iControl.axisSelect({a:25});
	logger("EggSlicer(): Done.");
};
</script>
</head>
<div id="Raphael"></div>
</html>
