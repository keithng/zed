<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>DaliPie - Consumer Price Index in a Bivariate Pie Thing</title>
<script src="./lib/jquery-1.9.1.min.js"></script>
<script src="./lib/raphael-min.js" type="text/javascript"></script>
<script src="./lib/zed.js" type="text/javascript"></script>
<script src="./data/NZ DaliPie.data" type="text/javascript"></script>
<style>
	.text {color:#ccc; font-family:sans-serif; font-size:13px}
	.alttext {color:#000; font-family:sans-serif; font-size:13px}
	.subtitle {font-size:14px; font-weight:bold}
	.title {font-size:18px; font-weight:bold}
</style>

<script type="text/javascript" charset="utf-8">
window.onload = function () {
	BASE_TIME = 1, INIT_TIME = 23;
	WEIGHTS = ["Jun 2006 Weights", "Jun 2008 Weights", "Jun 2011 Weights"];
	logger("DaliPie(): Initialising.");
	var L = new zLayout({
		width:Math.max(1200, $(window).width() - $("#Raphael").offset().left * 2), // Fit to screen, with minimum size
		height:Math.max(600, $(window).height() - $("#Raphael").offset().top * 2.75), // Fit to screen, with minimum size
		margin:50
	});
	with (L) {
		L.tooltipBox = {
			width:280, // TooltipBox is floating, so position doesn't need to be defined, and height is automatic (depending on text)
			height:"auto"
		};
		L.tAxis = {
			x:20, y:20,
			width:width - 40, height:20
		};
		L.swarm = new zLayout({
			anchor:getPoint(1, 1, true),
			width:innerWidth * 0.55, height:innerHeight - 60,
			xAlign:"right", yAlign:"bottom",
			innerRadius:height * 0.1,
			outerRadius:height * 0.25
		});
		L.sideSwarm = new zLayout({
			x:left, y:bottom,
			width:width * 0.4, height:innerHeight + 40,
			xAlign:"left", yAlign:"bottom",
			margin:60
		});
		L.credits = {
			anchor:getPoint(1, 1, true),
			xAlign:"right", yAlign:"bottom"
		};
	};
	with (L.sideSwarm) {
		L.fakeTAxis = {
			anchor:getPoint(0, 0, true), // Last flag ("true") tells getPoint to innerSpace, which takes margins into consideration
			width:innerWidth,
			xAlign:"left", yAlign:"top"
		};
		L.dAxis = {
			anchor:getPoint(0, 0, true),
			width:height * 0.55, height:innerWidth,
			xAlign:"right", yAlign:"top",
			rotation:90
		};
	};

	var Y = zt.parseStyle({
		base:{
			lines:{
				"stroke-width":0.3,
				stroke:"#ccc"
			}
		},
		introText:{
			"z-index":9999, // To top
			"border":"solid 1px #c4dde2",
			"background-color":"#d4edf2",
			"font-family":"sans-serif",
			"font-size":"13px",
			"text-align":"center",
			opacity:0.9,
			margin:L.height * 0.35
		},
		tAxis:{
			maxNotches:20,
			select:{t:300},
			notchLabel:{
				margin:7,
				"font-size":12,
				"font-weight":"bold",
				fill:"#aaa"
			},
			baseNotch:{
				margin:5,
				"font-size":12,
				"font-weight":"bold",
				highlighted:{background:{opacity:1}},
				background:{
					rounded:10,
					fill:"white",
					opacity:0.75
				}
			}
		},
		swarm:{
			titlePos:1.6, // Extension of the title, as a ratio of the radius
			baseTitleDeg:-90,
			zoomedTitleDeg:-130,
			baseOffset:0,
			zoomedOffset:-45,
			minZoomDeg:35,
			spin:{t:600, e:"<>"},
			zoom:{t:600, e:"<>"},
			merge:{t:600, e:"<>"},
			rings:{
				label:{
					"font-weight":"bold",
					fill:"#888"
				},
				ring:{baseStyle:"base.lines"}
			},
			title:{
				fill:"#888",
				title:{
					format:["wrap", 22],
					"font-size":28,
					"font-weight":"bold"
				},
				subtitle:{
					"font-size":16
				}
			},
			slice:{
// 				stroke:null,
// 				"stroke-opacity":0,
				"stroke-width":0.2,
				"stroke-opacity":1,
				highlighted:{
	 				"stroke-opacity":0,
					opacity:1
				}
			}
		},
		sideSwarm:{
			select:{t:400, e:"<>"},
			text:{},
			bar:{
				rounded:0, // Force rounded so complex rectangles are drawn
				parallelSize:1,
				"stroke-width":0.5
			}
		},
		dAxis:{
			maxNotches:16,
			minNotchGap:0.01,
			axisTitle:{
				fill:"#ccc"
			},
			notch:{
				format:["number", "%"],
				fill:"#ccc",
				radialStart:-L.sideSwarm.innerWidth,
				radialEnd:2,
				branch:{baseStyle:"base.lines"},
				baseBranch:{
					stroke:"#ccc",
					"stroke-width":2,
					opacity:0.5
				}
			}
		},
		tooltipBox:{},
		credits:{fill:"#ccc"},
		background:{fill:"#060606"}
	});

	var i, j, k, dc, generations, ROOT;
	var RING_SCALE = 0.4;

	logger("DaliPie(): Collating and crunching data.");
// 	with (dc = new zDataCube(2).importSheet(rawSheet)) {
	with (dc = new zDataCube(2).importProtoCube(protoCube)) {
		generations = meta[0].generation;
// 		console.log(WEIGHTS);
		for (i = 0; i < WEIGHTS.length; i++) {
			for (j = generations.length - 1; j > 0; j--) {
				for k =
			};
			addCalcMeta(WEIGHTS[i], {d:0, a:"all"}, "hierarchic");
		};
// 		addCalcData("val", {as:"all"}, {d:1}, "decChange");
// 		setColour({d:0, a:"all"}, null, "hierarchic");
// 		setShown(0, generations[1]); // Start at top level
// 		setShown(1, shown[1].slice(1)); // Ignore first one
// 		ROOT = meta[0].generation[0][0];
	};

	return;

	logger("DaliPie(): Setting up canvas.");
	PAPER = Raphael("Raphael", L.width, L.height);
	//if ($.browser.msie && parseInt($.browser.version) < 9) PAPER.noAnimation = true;

	logger("DaliPie(): Drawing accessories.");
	var background = new zRectangle({layout:L, base:Y.background}),
		credits = new zTextBox({text:"Created by Keith Ng", layout:L.credits, base:Y.credits}),
		tAxis = new zSlideAxis({
			layout:L.tAxis, style:Y.tAxis,
			dc:dc, d:1, baseSelected:{a:BASE_TIME}, selected:{a:BASE_TIME},
			plan:{
				axisTitle:null, axisLine:null, notch:null,
				baseNotch:{
					ignore:false,
					init:function (S, A, D) {
						return {
							layer:1,
							mouseEvents:function (D) {
// 								D.tooltip(null, tooltipBox, {x:D.L.centre.x, y:D.L.top, xAlign:"xCentre", yAlign:"bottom", width:"auto"});
								D.drag(function (rx, ry, x) {S.setBase({a:S.pointToAPos({x:x})})});
							},
							tooltipText:"Drag to change base year"
						};
					}
				}
			}
		}),
		fakeTAxis = new zSmartAxis({layout:L.fakeTAxis, dc:dc, d:1, plan:{axisTitle:null, axisLine:null, notch:null, notchLabel:null}}),
		dAxis = new zAxis({plan:{axisLine:null}, layout:L.dAxis, style:Y.dAxis, scale:[0, 0.5], title:"Quarterly Change"}),
		tooltipBox = new zHTMLTooltipBox({layout:L.tooltipBox, base:Y.tooltipBox});

	logger("DaliPie(): Drawing main pie.");
	var swarm = new zSwarm({ // Resources
		layout:L.swarm, style:Y.swarm,
		dc:dc, axes:{t:tAxis}, parentAPos:ROOT, d:0,
		rSpace:["all", tAxis.rSelected],
		degOffset:0,
		pieCentre:L.swarm.getPoint(0.5, 0.45),
		radius:L.swarm.outerRadius,
		calcChange:function (A, aBase) {
			if (aBase == null) aBase = tAxis.baseASelected;
			var base = dc.getData("val", {as:[A[0], aBase]}),
				curr = dc.getData("val", {as:A}),
				out = curr / base;
			return (isNaN(out)) ? 0 : out - 1;
		},
		getTooltipText:function (A, D) {
			var S = this, currChangeVal, currChange,
				category = dc.getMeta("description", {d:0, a:A[0]}),
				weight = zt.format(dc.getMeta(S.weightLabel, {d:0, a:A[0]}), {m:"%", dp:1}),
				date = dc.getLabel({d:1, a:A[1]}),
				changeVal = S.calcChange(A),
				change = (changeVal) ? zt.format(changeVal, {m:"%", dp:1, forceSign:1}) : "No change";
			if (A[1] > 0) {
				currChangeVal = S.calcChange(A, A[1] - 1),
				currChange = (currChangeVal) ? zt.format(currChangeVal, {m:"%", dp:1, forceSign:1}) : "No change";
			};
			return "<div class='alttext'>" +
				"<div class='title'>" + category + "</div>" +
				((A[1] > 0) ? "<br><b>" + currChange + "</b> in " + date : "") +
				"<b><br>" + change + "</b> between " + S.baseDate + " and " + date +
				"<br>Contributes <b>" + weight + "</b> towards overall score" +
				"<b><i>" + ((D.role == "bar") ? "<br><br>Click to select this period" : (A[0] == ROOT) ? "" : "<br><br>Click to zoom " + ((S.parentAPos == ROOT) ? "in" : "out")) + "</i></b></div>";
		},
		focus:function (A) {
			var S = this, x;
			tooltipBox.hide();
			// Disaggregration
			if (S.parentAPos == ROOT) {
				S.parentAPos = A[0];
				x = {d:0, a:S.parentAPos};
				logger("Zooming in to " + dc.getMeta("description", x) + ".");
				S.manualRedraw({all:true, mode:{forceFrameRedraw:true}}, S.Y.spin.t, S.Y.spin.e, function () { // Spin to new offset
					var i, j, weightLabel, currDeg, change, currRadius,
						focusArea, focusDist, focusScale,
						children = dc.findChildren(x),
						points = [S.pieCentre];
					for (i = 0; i < dc.getSize(1); i++) {
						weightLabel = dc.getMeta("weight", {d:1, a:i});
						currDeg = S.Y.zoomedOffset - 90 - 180 * dc.getMeta(weightLabel, x);
						for (j = 0; j < children.length; j++) {
							change = S.calcChange([children[j], i]);
							currRadius = S.L.outerRadius * Math.sqrt(change + 1),
							points.push(zp.addVector(currDeg, currRadius, S.pieCentre));
							currDeg += dc.getMeta(weightLabel, {d:0, a:children[j]}) * 360;
							points.push(zp.addVector(currDeg, currRadius, S.pieCentre));
						};
					};
					focusArea = zp.completeBox(zp.pointsToBox(points));
					focusDist = zp.calcDist(S.L.centre, {x:focusArea.xCentre, y:focusArea.yCentre});
					focusScale = Math.min(S.L.width / focusArea.width, S.L.height / focusArea.height) * 0.75;
					S.pieCentre = zp.addVector(zp.inverseDeg(S.Y.zoomedOffset - 90), focusDist * focusScale, S.L.centre);
					S.radius = S.L.outerRadius * focusScale;
					S.redraw(S.Y.zoom.t, S.Y.zoom.e, function () { // Zoom into focused slice
						S.add("rings", S.Y.merge.t, S.Y.merge.e, null, S.K);
						S.disaggregate(x, S.Y.merge.t, S.Y.merge.e);
					});
				});
			// Aggregration
			} else {
				x = {d:0, a:S.parentAPos};
				logger("Zooming out from " + dc.getMeta("description", x) + ".");
				S.remove("rings", S.Y.merge.t, S.Y.merge.e, null, S.K);
				S.aggregate({a:dc.findChildren(x)[0]}, S.Y.merge.t, S.Y.merge.e, function () {
					S.parentAPos = ROOT;
					S.pieCentre = S.L.getPoint(0.5, 0.45);
					S.radius = S.L.outerRadius;
					S.manualRedraw({all:true, mode:{noUpdateData:true}}, S.Y.zoom.t, S.Y.zoom.e, function () { // Zoom out
						S.manualRedraw({all:true, mode:{forceFrameRedraw:true}}, S.Y.spin.t, S.Y.spin.e); // Spin back into position
					});
				});
			};
		},
		updateData:function () {
			var S = this, dec, deg;
			S.baseDate = dc.getLabel({d:1, a:BASE_TIME});
			S.currDate = dc.getLabel({d:1, a:tAxis.aSelected});
			S.weightLabel = dc.getMeta("weight", {d:1, a:tAxis.aSelected});
			if (S.parentAPos == ROOT) S.degOffset = S.Y.baseOffset;
			else {
				dec = dc.getMeta(S.weightLabel + "Stacked", {d:0, a:S.parentAPos});
				deg = 360 * zt.mid(0.5, dec.start, dec.end); // deg is the midDeg of the parentAPos segment
				S.degOffset = zp.normaliseDeg(S.Y.zoomedOffset - deg, -180, 180);
			};
		},
		plan:{
			rings:{
				type:"zMultiDrone", mask:"fixed", ignore:true,
				init:function (S, A, D) {
					var i, radius, out = [];
					for (i = 0; i < RING_SCALE; i += 0.2) {
						radius = S.radius * Math.sqrt(1 + i);
						out.push({
							type:"zMultiDrone",
							label:{
								type:"zTextBox",
								text:zt.format(i, "%"),
								layout:{anchor:zp.addVector(225, radius, S.pieCentre), xAlign:"right", yAlign:"bottom"}
							},
							ring:{
								type:"zCircle",
								circle:{centre:S.pieCentre, radius:radius}
							}
						})
					};
					return out;
				}
			},
			title:{
				type:"zMultiDrone", mask:"fixed",
				curr:function (S, A, D) {
					var description = (S.parentAPos == ROOT) ? "Total" : dc.getMeta("description", {d:0, a:S.parentAPos}),
						change = S.calcChange([S.parentAPos, tAxis.aSelected]),
						layout = {
							anchor:S.pieCentre,
							radial:(S.parentAPos == ROOT) ? S.Y.baseTitleDeg : S.Y.zoomedTitleDeg,
							radialStart:S.radius * Math.sqrt(S.Y.titlePos)
						};
					return {
						title:{
							type:"zTextBox",
							text:description + " (" + zt.format(change, {mode:"%", dp:1, forceSign:true}) + ")",
							layout:zo.clone(layout, {yAlign:"bottom"})
						},
						subtitle:{
							type:"zTextBox",
							text:"from " + S.baseDate + " to " + S.currDate,
							layout:zo.extend(layout, {yAlign:"top"})
						}
					};
				}
			},
			slice:{
				type:"zArc", mask:"mask", directRedraw:true,
				curr:function (S, A, D, Y, mode) {
					var x = {d:0, a:A[0]},
						currItem = (mode.aggregate || mode.disaggregate) ? dc.findParent(x) : A[0], // If it's being inserted or removed, use parent's value
						dec = dc.getMeta(S.weightLabel + "Stacked", x),
						colour = dc.getMeta("colour", {d:0, a:currItem}),
						change = S.calcChange([currItem, A[1]]),
						inactive = (S.parentAPos != ROOT) && (S.parentAPos != A[0]) && (dc.getNode(x).generation == 1);
					return {
						tooltipText:S.getTooltipText(A, D),
						arc:{
							centre:S.pieCentre,
							degStart:zp.decToDeg(dec.start) + S.degOffset,
							degEnd:zp.decToDeg(dec.end) + S.degOffset,
							innerRadius:0,
							outerRadius:S.radius * Math.sqrt(change + 1)
						},
						fill:colour,
						opacity:(inactive) ? 0.1 : 0.8,
						mouseEvents:function (D) {
							if (inactive) return;
							D.hoverHighlight(100);
							D.tooltip(null, tooltipBox, {width:L.tooltipBox.width});
							D.hover(function () {
								sideSwarm.aSelected = A[0];
								sideSwarm.setSpace(x);
								sideSwarm.redraw(sideSwarm.Y.select.t, sideSwarm.Y.select.e);
							});
							D.click(function () {S.focus(A)});
						}
					};
				}
			}
		}
	});

	logger("DaliPie(): Drawing side bar graph.");
	var sideSwarm = new zSwarm({ // Resources
		layout:L.sideSwarm, style:Y.sideSwarm,
		dc:dc, d:1, aSelected:0,
		rSpace:[0, "all"],
		axes:{i:fakeTAxis, d:dAxis, t:tAxis},
		updateData:function () {
			var S = this,
				x = {d:0, a:S.aSelected},
				val = dc.calcData("valDecChange", {as:[(S.aSelect == null) ? S.aSelected : ROOT, dc.shown[1]]}), // aSpace is awkward because S.selected needs to be an aPos while "all" needs to be an rPos
				minVal = Math.min(za.min(val) * 1.2, 0),
				maxVal = Math.max(za.max(val) * 1.2, 0);
			dAxis.setScale([minVal, maxVal], (S.frame == null) ? null : S.Y.select.t, S.Y.select.e, null, S.K);
			S.description = dc.getMeta("description", x),
			S.colour = dc.getMeta("colour", x);
			S.weight = dc.getMeta(swarm.weightLabel, x),
			S.baseLine = dAxis.getPoint(0).y;
		},
		plan:{
			text:{
				type:"zHTML", mask:"fixed",
				init:function (S, A, D) {
					return {
						layout:{
							anchor:S.L.getPoint(0, 1, true),
							width:S.L.innerWidth
						}
					};
				},
				curr:function (S, A, D) {
					var node = dc.getNode({d:0, a:S.aSelected}),
						childrenCount = node.children.length,
						parentName = dc.getMeta("description", {d:0, a:node.parent}),
						change = swarm.calcChange([S.aSelected, tAxis.aSelected]),
						quarterChange = dc.getData("valDecChange", {as:[S.aSelected, tAxis.aSelected]});
					return {content:
						"<div class='text title'>" + S.description + "</div><p>" +
						"<div class='text'>" + S.description + ((childrenCount) ? " contains " + childrenCount + " subcategories" : " is a subcategory of " + parentName) +
						", and is " + zt.format(S.weight, {m:"%", dp:1}) + " of the CPI basket (" + swarm.weightLabel + ").<p>" +
						"Prices " + ((quarterChange < 0) ? "fell" : "rose") + " by " +
						zt.format(quarterChange, {m:"%", dp:1, noSign:1}) + " in the " + swarm.currDate + " quarter.<p>" +
						"Prices were " + zt.format(change, {m:"%", dp:1, noSign:1}) + ((change < 0) ? " lower" : " higher") +
						" in " + swarm.currDate + " than they were in " + swarm.baseDate + ".</div>"
					};
				}
			},
			bar:{
				type:"zRectangle", mask:"mask",
				init:function (S, A, D, Y) {
					return {
						layout:{
							width:S.axes.i.getLength(Y.parallelSize),
							xAlign:"xCentre", yAlign:"bottom"
						},
						mouseEvents:function (D) {
							D.tooltip(null, tooltipBox, {width:L.tooltipBox.width});
							D.click(function () {
								tooltipBox.hide();
								tAxis.axisSelect({a:A[1]}, tAxis.Y.select.t, tAxis.Y.select.e);
							});
						}
					};
				},
				curr:function (S, A, D) {
					var x = {d:1, a:A[1]},
						val = dc.getData("valDecChange", {as:[S.aSelected, A[1]]});
					return {
						tooltipText:swarm.getTooltipText(A, D),
						layout:{
							x:S.axes.i.getPoint(x).x, y:S.baseLine,
							height:S.axes.d.getLength(val)
						},
						fill:S.colour,
						opacity:(A[1] == tAxis.aSelected) ? 1 : 0.5
					};
				}
			}
		}
	});

	logger("DaliPie(): Done.");
	tAxis.axisSelect({a:BASE_TIME});
	var introText = new zHTML({
		content:
			"<div class='title'>Consumer Price Index</div><br>" +
			"This is a visualisation of the Consumer Price Index. The bar graph on the left shows quarterly changes. The DaliPie graph on the left show total changes. " +
			"The wider the slice, the more important that group is to the overall index (angle = weighting in the CPI basket of groups).<br><br>" +
			"The more each slice sticks out, the more the price has increased (area is proportional to the cumulative change in that group).<br><br>" +
			"Click on a slice to see its subgroups.<br><br>" +
			"Click on the top bar to change to a different period.<br><br>" +
			"<b><i>Click anywhere to begin.</i></b>",
		layout:L, base:Y.introText});
	introText.click(function () {
		introText.remove(500);
// 		tAxis.axisSelect({a:INIT_TIME}, tAxis.Y.select.t, tAxis.Y.select.e);
		tAxis.axisSelect({a:INIT_TIME}, 80, tAxis.Y.select.e);
	});
};

</script>
</head>
<body>
    <div id="Raphael"></div>
</body>
</html>
