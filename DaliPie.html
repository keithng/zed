<!DOCTYPE HTML>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=9">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>DaliPie: Animated Disaggregating Bivariate Pie</title>
<script src="./lib/jquery-1.9.1.min.js"></script>
<script src="./lib/raphael-min.js" type="text/javascript"></script>
<script src="./lib/zed.js" type="text/javascript"></script>
<script src="./data/DaliPie.data" type="text/javascript"></script>
<style>
	.text {color:#ccc; font-family:sans-serif; font-size:13px}
	.alttext {color:#000; font-family:sans-serif; font-size:13px}
	.subtitle {font-size:14px; font-weight:bold}
	.title {font-size:18px; font-weight:bold}
</style>

<script type="text/javascript" charset="utf-8">
window.onload = function () {
	BASE_TIME = 1, INIT_TIME = 23;
	WEIGHTS = ["Jun 2006 Weights", "Jun 2008 Weights", "Jun 2011 Weights"];
	logger("DaliPie(): Initialising.");
	var L = new zLayout({
		width:Math.max(1200, $(window).width() - $("#Raphael").offset().left * 2), // Fit to screen, with minimum size
		height:Math.max(600, $(window).height() - $("#Raphael").offset().top * 2.75), // Fit to screen, with minimum size
		margin:50
	});
	with (L) {
		L.tooltipBox = {
			width:280, // TooltipBox is floating, so position doesn't need to be defined, and height is automatic (depending on text)
			height:"auto"
		};
		L.tAxis = {
			x:20, y:20,
			width:width - 40, height:20
		};
		L.swarm = new zLayout({
			anchor:getPoint(1, 1, true),
			width:innerWidth * 0.55, height:innerHeight - 160,
			xAlign:"right", yAlign:"bottom",
			innerRadius:height * 0.1,
			outerRadius:height * 0.25
		});
		L.sideSwarm = new zLayout({
			x:left, y:bottom,
			width:width * 0.4, height:innerHeight + 40,
			xAlign:"left", yAlign:"bottom",
			margin:60
		});
		L.credits = {
			anchor:getPoint(1, 1, true),
			xAlign:"right", yAlign:"bottom"
		};
	};
	with (L.sideSwarm) {
		L.fakeTAxis = {
			anchor:getPoint(0, 0, true), // Last flag ("true") tells getPoint to innerSpace, which takes margins into consideration
			width:innerWidth,
			xAlign:"left", yAlign:"top"
		};
		L.dAxis = {
			anchor:getPoint(0, 0, true),
			width:height * 0.55, height:innerWidth,
			xAlign:"right", yAlign:"top",
			rotation:90
		};
	};

	var Y = zt.parseStyle({
		base:{
			lines:{
				"stroke-width":0.3,
				stroke:"#ccc"
			}
		},
		introText:{
			"z-index":9999, // To top
			"border":"solid 1px #c4dde2",
			"background-color":"#d4edf2",
			"font-family":"sans-serif",
			"font-size":"13px",
			"text-align":"center",
			opacity:0.9,
			margin:L.height * 0.35
		},
		tAxis:{
			maxNotches:20,
			select:{t:300},
			notchLabel:{
				margin:7,
				"font-size":12,
				"font-weight":"bold",
				fill:"#aaa"
			},
			baseNotch:{
				margin:5,
				"font-size":12,
				"font-weight":"bold",
				highlighted:{background:{opacity:1}},
				background:{
					rounded:10,
					fill:"white",
					opacity:0.75
				}
			}
		},
		swarm:{
			titlePos:1.6, // Extension of the title, as a ratio of the radius
			baseTitleDeg:-90,
			zoomedTitleDeg:-130,
			baseOffset:0,
			zoomedOffset:-135,
			minZoomDeg:35,
			spin:{t:600, e:"<>"},
			zoom:{t:600, e:"<>"},
			merge:{t:600, e:"<>"},
			rings:{
				label:{
					"font-weight":"bold",
					fill:"#888"
				},
				ring:{baseStyle:"base.lines"}
			},
			title:{
				fill:"#888",
				title:{
					format:["wrap", 22],
					"font-size":28,
					"font-weight":"bold"
				},
				subtitle:{
					"font-size":16
				}
			},
			slice:{
// 				stroke:null,
// 				"stroke-opacity":0,
				opacity:0.9,
				"stroke-width":0.2,
				"stroke-opacity":1,
				highlighted:{
	 				"stroke-opacity":0,
					opacity:1
				},
				faded:{opacity:0.1}
			}
		},
		sideSwarm:{
			select:{t:400, e:"<>"},
			text:{},
			bar:{
				rounded:0, // Force rounded so complex rectangles are drawn
				parallelSize:1,
				"stroke-width":0.5
			}
		},
		dAxis:{
			maxNotches:16,
			minNotchGap:0.01,
			axisTitle:{
				fill:"#ccc"
			},
			notch:{
				format:["number", "%"],
				fill:"#ccc",
				radialStart:-L.sideSwarm.innerWidth,
				radialEnd:2,
				branch:{baseStyle:"base.lines"},
				baseBranch:{
					stroke:"#ccc",
					"stroke-width":2,
					opacity:0.5
				}
			}
		},
		tooltipBox:{},
		credits:{fill:"#ccc"},
		background:{fill:"#060606", opacity:0.1}
	});

	var ROOT, RINGS = [0, 0.2, 0.4];

	logger("DaliPie(): Collating and crunching data.");
	var dc = new zDataCube(3);
	with (dc) {
		importStrip(rawStrip);

		// Categories
		ROOT = meta[2].hierarchy[0][0];
 		setShown(2, meta[2].hierarchy[1]);
 		calcHierarchyData("stacked", "weight", 2);
		setColour({d:2}, null, "hierarchic");
	};

	logger("DaliPie(): Setting up canvas.");
	PAPER = Raphael("Raphael", L.width, L.height);
	//if ($.browser.msie && parseInt($.browser.version) < 9) PAPER.noAnimation = true;
	logger("DaliPie(): Drawing accessories.");
	var background = new zRectangle({layout:L, base:Y.background}),
		credits = new zTextBox({text:"Created by Keith Ng", layout:L.credits, base:Y.credits}),
		tAxis = new zSlideAxis({
			layout:L.tAxis, style:Y.tAxis,
			dc:dc, d:0,
			baseSelected:{a:0},
			selected:{a:dc.getSize(0) - 1},
			plan:{axisTitle:null, axisLine:null}
		}),
		fakeTAxis = new zSmartAxis({
			layout:L.fakeTAxis, dc:dc, d:0,
			plan:{axisTitle:null, axisLine:null, notch:null, notchLabel:null}
		}),
		dAxis = new zAxis({
			layout:L.dAxis, style:Y.dAxis,
			scale:[0, 0.5], title:"Quarterly Change",
			plan:{axisLine:null}
		}),
		tooltipBox = new zHTMLTooltipBox({layout:L.tooltipBox, base:Y.tooltipBox});

	logger("DaliPie(): Drawing main pie.");
	var swarm = new zSwarm({ // Resources
		layout:L.swarm, style:Y.swarm,
		dc:dc, axes:{t:tAxis}, d:2,
		selected:{a:ROOT},
		rSpace:[tAxis.selected.r, 0, "all"],
		getState:function (A) {
			var S = this,
				parent = dc.findParent({d:2, as:A});
			return (
				(A[2] == S.selected.a) ? "parent" :
				(parent == S.selected.a) ? "child" :
				"inactive");
		},
		getWeightStacked:function (A) {
			return dc.getData("weightStacked", {as:[tAxis.baseSelected.a, A[1], A[2]]});
		},
		getWeight:function (A) {
			return dc.getData("weight", {as:[tAxis.baseSelected.a, A[1], A[2]]});
		},
		getVal:function (A) {
			return dc.getData("val", {as:A});
		},
		getDeg:function (A) {
			var S = this,
				dec = S.getWeightStacked(A);
			return {
				start:S.offset + zp.decToDeg(dec.start),
				end:S.offset + zp.decToDeg(dec.end)
			};
		},
		getChange:function (A, baseTime) {
			if (baseTime == null) baseTime = tAxis.baseSelected.a;
			var S = this,
				base = S.getVal([baseTime, A[1], A[2]]),
				curr = S.getVal(A),
				out = (curr / base);
			return (isNaN(out)) ? 0 : out;
		},
// 		// Dynamic weight mode
// 		getWeightStacked:function (A) {
// 			return dc.getData("weightStacked", {as:A});
// 		},
// 		getWeight:function (A) {
// 			return dc.getData("weight", {as:A});
// 		},
// 		getChange:function (A, baseTime) {
// 			if (A[0] == 0) return 1;
// 			var weights = dc.getData("weight", {as:["all", 0, A[2]]}),
// 				currWeight = this.getWeight(A),
// 				aPos = za.find(weights, currWeight);
// 			var S = this,
// 				base = S.getVal([aPos, A[1], A[2]]),
// 				curr = S.getVal(A),
// 				out = (curr / base);
// 			return (isNaN(out)) ? 0 : out;
// 		},
		getTooltipText:function (A, D) {
			var S = this,
				asPercent = function (dec) {
					return (dec) ? zt.format(dec, {m:"%", dp:1, forceSign:1}) : "No change";
				},
				time = dc.getName({d:0, as:A}),
				baseTime = dc.getName(tAxis.baseSelected),
				category = dc.getMeta("description", {d:2, as:A}),
				weight = dc.getData("weight", {as:A}),
				change = S.getChange(A) - 1,
				currChange = (A[0] > 0) ? S.getChange(A, A[0] - 1) - 1 : null;
			return "<div class='alttext'>" +
				"<div class='title'>" + category + "</div>" +
				((A[0] > 0) ? "<br><b>" + asPercent(currChange) + "</b> in " + time : "") +
				"<br><b>" + asPercent(change) + "</b> between " + baseTime + " and " + time +
				"<br><b>" + asPercent(weight) + "</b> of " + baseTime + " CPI basket" +
				"<b><i>" + ((D.role == "bar") ? "<br><br>Click to select this period" : (A[2] == ROOT) ? "" : "<br><br>Click to zoom " + ((S.zoomed) ? "out" : "in")) + "</i></b></div>";
		},
		updateSpin:function () {
			var S = this, oldDeg, newDeg,
				A = [tAxis.selected.a, 0, S.selected.a];
			if (S.zoomed) {
				oldDeg = zo.midStack(S.getDeg(A)); // Find bisect of segment
				newDeg = S.Y.zoomedOffset + S.offset - oldDeg; // Convert to offset
				S.offset = zp.matchDeg(newDeg, S.offset); // Use matchDeg to ensure spin in the right direction
			} else S.offset = S.Y.baseOffset; // Default angle
		},
		updateZoom:function () {
			var S = this;
			if (S.zoomed) {
				var zoomArea, points = [],
					children = dc.findChildren(S.selected);
				dc.forSpaces(["all", 0, children], function (x) { // Targeted category and all its children
					var deg = S.getDeg(x.as),
						val = S.getChange(x.as),
						arcPoints = zp.arcToPoints(S.centre, S.radius * 0.2, S.radius * Math.sqrt(val), deg.start, deg.end); // Calculate its edge points
					points = points.concat(arcPoints);
				});
				zoomArea = zp.completeBox(zp.pointsToBox(points)); // Turn points into a box - that's the zoomArea
				S.L.zoom(zoomArea); // Zoom into it
			};
			S.radius = S.L.innerHeight * 0.5;
			S.centre = S.L.getPoint(0.5, 0.5, true);
			S.L.unzoom(); // Always unzoom after calculating new radius/centre
		},
		onInit:function () {
			var S = this;
			S.updateSpin();
			S.updateZoom();
		},
		updateData:function () {},
		select:function (A) {
			var S = this, parent, children;
			tooltipBox.hide();
 			if (A[2] == ROOT) return; // Do not zoom to root
			// Aggregration (zoom out)
			if (S.zoomed) {
				parent = dc.findParent(S.selected);
				children = dc.findChildren(S.selected);
				S.refresh({d:S.d, a:children, mode:{aggregate:true}}, S.Y.merge.t, S.Y.merge.e, function () { // Merge children back into parent
					S.aggregate({d:S.d, a:children[0]}); // Remove children
					tAxis.layer(); // Bring tAxis in front of swarms
					S.selected = {d:S.d, a:parent};
					S.zoomed = false;
					S.updateZoom();
					S.updateSpin();
					S.refresh("all", S.Y.zoom.t, S.Y.zoom.e); // Zoom out and spin back into position
				});
			// Disaggregration (zoom in)
			} else {
				S.selected = {d:S.d, a:A[S.d]};
				S.zoomed = true;
				S.updateSpin();
				S.refresh("all", S.Y.spin.t, S.Y.spin.e, function () { // Spin to new offset (angle of spin will be calculated by updateData once CATEGORY is updated)
					S.updateZoom();
					S.refresh("all", S.Y.zoom.t, S.Y.zoom.e, function () { // Find boundary for all children and zoom in
						S.disaggregate(S.selected);
						tAxis.layer(); // Bring tAxis in front of swarms
						S.refresh("all", S.Y.merge.t, S.Y.merge.e);
					});
				});
			};
		},
		plan:{
			rings:{
				type:"zMultiDrone", mask:"fixed",
				init:function (S, A, D) {
					var i, val, out = [];
					for (i = 0; i < RINGS.length; i++) {
						val = RINGS[i];
						out.push({
							type:"zMultiDrone",
							label:{
								type:"zTextBox",
								text:zt.format(val, "%"),
								layout:{xAlign:"right", yAlign:"bottom"}
							},
							ring:{type:"zCircle"}
						})
					};
					return out;
				},
				curr:function (S, A, D) {
					var i, val, radius, out = [];
					for (i = 0; i < RINGS.length; i++) {
						val = 1 + RINGS[i];
						radius = S.radius * Math.sqrt(val);
						out.push({
							label:{
								layout:zp.addVector(225, radius, S.centre)
							},
							ring:{
								circle:{centre:S.centre, radius:radius}
							}
						})
					};
					return out;
				}
			},
			title:{
				type:"zMultiDrone", mask:"fixed",
				init:function (S, A, D) {
					return {
						title:{type:"zTextBox", layout:{yAlign:"bottom"}},
						subtitle:{type:"zTextBox", layout:{yAlign:"top"}}
					};
				},
				curr:function (S, A, D) {
					var name = (S.zoomed) ? dc.getName(S.selected) : "Total",
						val = S.getChange([tAxis.selected.a, 0, S.selected.a]) - 1,
						time = dc.getName(tAxis.selected),
						baseTime = dc.getName(tAxis.baseSelected),
						layout = {
							anchor:S.centre,
							radial:(S.zoomed) ? S.Y.zoomedTitleDeg : S.Y.baseTitleDeg,
							radialStart:S.radius * Math.sqrt(S.Y.titlePos)
						};
					return {
						title:{
							text:name + " (" + zt.format(val, {mode:"%", dp:1, forceSign:true}) + ")",
							layout:layout
						},
						subtitle:{
							text:"from " + baseTime + " to " + time,
							layout:layout
						}
					};
				}
			},
			slice:{
				type:"zArc", mask:"mask",
				curr:function (S, A, D, Y, mode) {
					var deg = S.getDeg(A),
						aPos = (mode.aggregate || mode.disaggregate) ? dc.findParent({d:S.d, as:A}) : A[S.d], // If it's being inserted or removed, use parent's value
						colour = dc.getMeta("colour", {d:S.d, a:aPos}),
						opacity = (S.getState(A) == "inactive") ? Y.faded.opacity : Y.opacity, // Element is inactive if it is not a child of the selected element
						val = S.getChange([A[0], A[1], aPos]);
					return {
						arc:{centre:S.centre, innerRadius:0, outerRadius:S.radius * Math.sqrt(val), degStart:deg.start, degEnd:deg.end, minSeg:4},
						fill:colour, opacity:opacity,
						mouseEvents:function (D) {
							if (S.getState(D.A) == "child") { // Element is inactive if it is not a child of the selected element
	 							D.hoverHighlight(100);
								D.tooltip(null, tooltipBox, {width:L.tooltipBox.width});
								D.hover(function () {
									sideSwarm.selected = {d:2, a:D.A[2]}; // Use .selected rather than .setSpace() to control sideSwarm because if parent is selected, .setSpace() won't work because parent isn't part of .shown
									sideSwarm.refresh("all", sideSwarm.Y.select.t, sideSwarm.Y.select.e);
								});
							};
							D.click(function () {S.select(D.A)});
						},
						tooltipText:S.getTooltipText(A, D)
					};
				}
			}
		}
	});

	logger("DaliPie(): Drawing side bar graph.");
	var sideSwarm = new zSwarm({ // Resources
		layout:L.sideSwarm, style:Y.sideSwarm,
		dc:dc, selected:{d:2, a:0},
		rSpace:["all", 0, "na"],
		axes:{i:fakeTAxis, d:dAxis, t:tAxis},
		getVal:function (time, baseTime) {
			var S = this;
			return swarm.getChange([time, 0, S.selected.a], baseTime) - 1;
		},
		getWeight:function (time) {
			var S = this;
			return dc.getData("weight", {as:[time, 0, S.selected.a]});
		},
		updateData:function () {
			var S = this, i, val = [];
			for (i = 0; i < dc.getSize(0); i++) {
				val.push(S.getVal(i));
			};
			range = [
				Math.min(za.min(val) * 1.2, 0),
				Math.max(za.max(val) * 1.2, 0)
			];
			dAxis.setShown(range, (S.frame == null) ? null : S.Y.select.t, S.Y.select.e, null, S.K);
			S.name = dc.getName(S.selected);
			S.colour = dc.getMeta("colour", S.selected);
			S.baseLine = dAxis.getPoint(0).y;
		},
		plan:{
			text:{
				type:"zHTML", mask:"fixed",
				init:function (S, A, D) {
					return {
						layout:{
							anchor:S.L.getPoint(0, 1, true),
							width:S.L.innerWidth
						}
					};
				},
				curr:function (S, A, D) {
					var parentName = dc.getFamily("parent", "name", S.selected),
						children = dc.findChildren(S.selected),
						time = dc.getName(tAxis.selected),
						baseTime = dc.getName(tAxis.baseSelected),
						weight = swarm.getWeight([tAxis.selected.a, 0, S.selected.a]),
						change = S.getVal(tAxis.selected.a),
						quarterChange = S.getVal(tAxis.selected.a, tAxis.selected.a - 1);
					return {content:
						"<div class='text title'>" + S.name + "</div><p>" +
						"<div class='text'>" + S.name + ((children.length) ? " contains " + children.length + " subcategories" : " is a subcategory of " + parentName) +
						" and was " + zt.format(weight, {m:"%", dp:1}) + " of the " + baseTime + " CPI basket.<p>" +
						"Prices " + ((quarterChange < 0) ? "fell" : "rose") + " by " +
						zt.format(quarterChange, {m:"%", dp:1, noSign:1}) + " in the " + time + " quarter, " +
						"and were " + zt.format(change, {m:"%", dp:1, noSign:1}) + ((change < 0) ? " lower" : " higher") +
						" than they were in " + baseTime + ".</div>"
					};
				}
			},
			bar:{
				type:"zRectangle", mask:"mask",
				init:function (S, A, D, Y) {
					return {
						layout:{
							width:S.axes.i.getLength(Y.parallelSize),
							xAlign:"xCentre", yAlign:"bottom"
						},
						mouseEvents:function (D) {
							D.tooltip(null, tooltipBox, {width:L.tooltipBox.width});
							D.click(function () {
								tooltipBox.hide();
								tAxis.axisSelect({a:A[0]}, tAxis.Y.select.t, tAxis.Y.select.e);
							});
						}
					};
				},
				curr:function (S, A, D) {
					var x = {d:0, a:A[0]},
						val = S.getVal(A[0]);
					return {
						tooltipText:swarm.getTooltipText([A[0], A[1], S.selected.a], D),
						layout:{
							x:S.axes.i.getPoint(x).x, y:S.baseLine,
							height:S.axes.d.getLength(val)
						},
						fill:S.colour,
						opacity:(A[0] == tAxis.selected.a) ? 1 : 0.5
					};
				}
			}
		}
	});
	logger("DaliPie(): Done.");
	return;

	tAxis.axisSelect({a:BASE_TIME});
	var introText = new zHTML({
		content:
			"<div class='title'>Consumer Price Index</div><br>" +
			"This is a visualisation of the Consumer Price Index. The bar graph on the left shows quarterly changes. The DaliPie graph on the left show total changes. " +
			"The wider the slice, the more important that group is to the overall index (angle = weighting in the CPI basket of groups).<br><br>" +
			"The more each slice sticks out, the more the price has increased (area is proportional to the cumulative change in that group).<br><br>" +
			"Click on a slice to see its subgroups.<br><br>" +
			"Click on the top bar to change to a different period.<br><br>" +
			"<b><i>Click anywhere to begin.</i></b>",
		layout:L, base:Y.introText});
	introText.click(function () {
		introText.remove(500);
// 		tAxis.axisSelect({a:INIT_TIME}, tAxis.Y.select.t, tAxis.Y.select.e);
		tAxis.axisSelect({a:INIT_TIME}, 80, tAxis.Y.select.e);
	});
};

</script>
</head>
<body>
    <div id="Raphael"></div>
</body>
</html>
